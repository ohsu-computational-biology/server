"""
DO NOT EDIT THIS FILE!!
This file is automatically generated by the process_schemas.py program
in the scripts directory. It is not intended to be edited directly. If
you need to update the GA4GH protocol classes, please run the script
on the appropriate schema version.
"""
from protocol import ProtocolElement
from protocol import SearchRequest
from protocol import SearchResponse

import avro.schema

version = '0.6.4f91841a9a'


class Attributes(ProtocolElement):
    """
    Type defining a collection of attributes associated with various
    protocol   records.  Each attribute is a name that maps to an
    array of one or more   values.  Values can be strings, external
    identifiers, or ontology terms.   Values should be split into the
    array elements instead of using a separator   syntax that needs to
    parsed.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Attributes", "fields": [{"default": {}, "type": {"values": {"items":
["string", {"doc": "", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}]}, {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}]}], "type": "array"}, "type": "map"}, "name": "vals"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'vals'
    ]

    def __init__(self, **kwargs):
        self.vals = kwargs.get(
            'vals', {})
        """
        No documentation
        """


class Call(ProtocolElement):
    """
    A Call represents the determination of genotype with respect to a
    particular Variant.  It may include associated information such as
    quality and phasing. For example, a call might assign a
    probability of 0.32 to the occurrence of a SNP named rs1234 in a
    call set with the name NA12345.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Call",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "callSetName"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "callSetId"}, {"default": [], "doc": "", "type":
{"items": "int", "type": "array"}, "name": "genotype"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "phaseset"},
{"default": [], "doc": "", "type": {"items": "double", "type":
"array"}, "name": "genotypeLikelihood"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetId', 'callSetName', 'genotype', 'genotypeLikelihood',
        'info', 'phaseset'
    ]

    def __init__(self, **kwargs):
        self.callSetId = kwargs.get(
            'callSetId', None)
        """
        The ID of the call set this variant call belongs to.    If
        this field is not present, the ordering of the call sets from
        a   SearchCallSetsRequest over this VariantSet is guaranteed
        to match   the ordering of the calls on this Variant.   The
        number of results will also be the same.
        """
        self.callSetName = kwargs.get(
            'callSetName', None)
        """
        The name of the call set this variant call belongs to.   If
        this field is not present, the ordering of the call sets from
        a   SearchCallSetsRequest over this VariantSet is guaranteed
        to match   the ordering of the calls on this Variant.   The
        number of results will also be the same.
        """
        self.genotype = kwargs.get(
            'genotype', [])
        """
        The genotype of this variant call.    A 0 value represents the
        reference allele of the associated Variant. Any   other value
        is a 1-based index into the alternate alleles of the
        associated   Variant.    If a variant had a referenceBases
        field of "T", an alternateBases   value of ["A", "C"], and the
        genotype was [2, 1], that would mean the call   represented
        the heterozygous value "CA" for this variant. If the genotype
        was instead [0, 1] the represented value would be "TA".
        Ordering of the   genotype values is important if the phaseset
        field is present.
        """
        self.genotypeLikelihood = kwargs.get(
            'genotypeLikelihood', [])
        """
        The genotype likelihoods for this variant call. Each array
        entry   represents how likely a specific genotype is for this
        call as   log10(P(data | genotype)), analogous to the GL tag
        in the VCF spec. The   value ordering is defined by the GL tag
        in the VCF spec.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional variant call information.
        """
        self.phaseset = kwargs.get(
            'phaseset', None)
        """
        If this field is not null, this variant call's genotype
        ordering implies   the phase of the bases and is consistent
        with any other variant calls on   the same contig which have
        the same phaseset string.
        """


class CallSet(ProtocolElement):
    """
    A CallSet is a collection of variant calls for a particular
    sample. It belongs to a VariantSet. This is equivalent to one
    column in VCF.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "CallSet",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"}, {"doc":
"", "type": ["null", "string"], "name": "sampleId"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"variantSetIds"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'id', 'info', 'name', 'sampleId', 'updated',
        'variantSetIds'
    ]

    def __init__(self, **kwargs):
        self.created = kwargs.get(
            'created', None)
        """
        The date this call set was created in milliseconds from the
        epoch.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The call set ID.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional call set information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The call set name.
        """
        self.sampleId = kwargs.get(
            'sampleId', None)
        """
        The sample this call set's data was generated from.
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this call set was last updated in
        milliseconds from the epoch.
        """
        self.variantSetIds = kwargs.get(
            'variantSetIds', [])
        """
        The IDs of the variant sets this call set has calls in.
        """


class CigarOperation(object):
    """
    An enum for the different types of CIGAR alignment operations that
    exist. Used wherever CIGAR alignments are used. The different
    enumerated values have the following usage:  * ALIGNMENT_MATCH: An
    alignment match indicates that a sequence can be   aligned to the
    reference without evidence of an INDEL. Unlike the
    SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the
    ALIGNMENT_MATCH   operator does not indicate whether the reference
    and read sequences are an   exact match. This operator is
    equivalent to SAM's M. * INSERT: The insert operator indicates
    that the read contains evidence of   bases being inserted into the
    reference. This operator is equivalent to   SAM's I. * DELETE: The
    delete operator indicates that the read contains evidence of
    bases being deleted from the reference. This operator is
    equivalent to   SAM's D. * SKIP: The skip operator indicates that
    this read skips a long segment of   the reference, but the bases
    have not been deleted. This operator is   commonly used when
    working with RNA-seq data, where reads may skip long   segments of
    the reference between exons. This operator is equivalent to
    SAM's 'N'. * CLIP_SOFT: The soft clip operator indicates that
    bases at the start/end   of a read have not been considered during
    alignment. This may occur if the   majority of a read maps, except
    for low quality bases at the start/end of   a read. This operator
    is equivalent to SAM's 'S'. Bases that are soft clipped   will
    still be stored in the read. * CLIP_HARD: The hard clip operator
    indicates that bases at the start/end of   a read have been
    omitted from this alignment. This may occur if this linear
    alignment is part of a chimeric alignment, or if the read has been
    trimmed   (e.g., during error correction, or to trim poly-A tails
    for RNA-seq). This   operator is equivalent to SAM's 'H'. * PAD:
    The pad operator indicates that there is padding in an alignment.
    This operator is equivalent to SAM's 'P'. * SEQUENCE_MATCH: This
    operator indicates that this portion of the aligned   sequence
    exactly matches the reference (e.g., all bases are equal to the
    reference bases). This operator is equivalent to SAM's '='. *
    SEQUENCE_MISMATCH: This operator indicates that this portion of
    the   aligned sequence is an alignment match to the reference, but
    a sequence   mismatch (e.g., the bases are not equal to the
    reference). This can   indicate a SNP or a read error. This
    operator is equivalent to SAM's 'X'.
    """
    ALIGNMENT_MATCH = "ALIGNMENT_MATCH"
    INSERT = "INSERT"
    DELETE = "DELETE"
    SKIP = "SKIP"
    CLIP_SOFT = "CLIP_SOFT"
    CLIP_HARD = "CLIP_HARD"
    PAD = "PAD"
    SEQUENCE_MATCH = "SEQUENCE_MATCH"
    SEQUENCE_MISMATCH = "SEQUENCE_MISMATCH"


class CigarUnit(ProtocolElement):
    """
    A structure for an instance of a CIGAR operation.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"CigarUnit", "fields": [{"doc": "", "type": {"symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT",
"CLIP_HARD", "PAD", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "",
"type": "enum", "name": "CigarOperation"}, "name": "operation"},
{"doc": "", "type": "long", "name": "operationLength"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"referenceSequence"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "operation",
        "operationLength",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'operation', 'operationLength', 'referenceSequence'
    ]

    def __init__(self, **kwargs):
        self.operation = kwargs.get(
            'operation', None)
        """
        The operation type.
        """
        self.operationLength = kwargs.get(
            'operationLength', None)
        """
        The number of bases that the operation runs for.
        """
        self.referenceSequence = kwargs.get(
            'referenceSequence', None)
        """
        referenceSequence is only used at mismatches
        (SEQUENCE_MISMATCH)   and deletions (DELETE). Filling this
        field replaces the MD tag.   If the relevant information is
        not available, leave this field as null.
        """


class Dataset(ProtocolElement):
    """
    A Dataset is a data-provider-specified collection of related data
    of multiple types. Logically, it's akin to a folder -- it's up to
    the provider what goes into the folder.  For server implementors,
    they're a useful level of granularity for implementing
    administrative features such as access control (e.g. Dataset X is
    public; Dataset Y is only available to lab Z's collaborators) and
    billing (e.g. the costs of hosting Dataset Y should be charged to
    lab Z).  For data curators, they're 'the simplest thing that could
    possibly work' for grouping data (e.g. Dataset X has all the
    reads, variants, and expression levels for a particular research
    project; Dataset Y has all the work product from a particular
    grant).  For data accessors, they're a simple way to scope
    exploration and analysis (e.g. are there any supporting examples
    in 1000genomes? what's the distribution of that result in the data
    from our project?)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Dataset",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"description"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'name'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        Additional, human-readable information on the dataset.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The dataset's id, (at least) locally unique.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the dataset.
        """


class EnvironmentalContext(ProtocolElement):
    """
    The context in which a genotype gives rise to a phenotype. This is
    fairly open-ended; as a stub we have a simple ontology term. For
    example, a controlled term for a drug, or perhaps an instance of a
    complex environment including temperature and air quality, or
    perhaps the anatomical environment (gut vs tissue type vs whole
    organism).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"EnvironmentalContext", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "id"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "OntologyTerm", "fields": [{"doc": "",
"type": "string", "name": "ontologySource"}, {"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}, "name": "environmentType"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "environmentType",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'environmentType': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'environmentType': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'environmentType', 'id'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A textual description of the environment. This is used to
        complement          the structured description in the
        environmentType field
        """
        self.environmentType = kwargs.get(
            'environmentType', None)
        """
        Examples of some environment types could be drawn from:
        Ontology for Biomedical Investigations (OBI):
        http://purl.obofoundry.org/obo/obi/browse   Chemical Entities
        of Interest (ChEBI):
        http://www.ontobee.org/browser/index.php?o=chebi   Environment
        Ontology (ENVO):
        http://www.ontobee.org/browser/index.php?o=ENVO   Anatomy
        (Uberon): http://www.ontobee.org/browser/index.php?o=uberon
        """
        self.id = kwargs.get(
            'id', None)
        """
        The Environment ID.
        """


class Evidence(ProtocolElement):
    """
    Evidence for the phenotype association. This is also a stub for
    further expansion.  We should consider moving this into  it's own
    schema.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Evidence", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "ontologySource"}, {"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}, "name": "evidenceType"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "evidenceType",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'evidenceType': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'evidenceType': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'evidenceType'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A textual description of the evidence. This is used to
        complement the          structured description in the
        evidenceType field
        """
        self.evidenceType = kwargs.get(
            'evidenceType', None)
        """
        ECO or OBI is recommended
        """


class EvidenceQuery(ProtocolElement):
    """
    Evidence for the phenotype association.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"EvidenceQuery", "fields": [{"doc": "", "type": {"items":
{"namespace": "org.ga4gh.models", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}], "doc": ""}, "type": "array"}, "name": "evidenceType"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "evidenceType",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'evidenceType': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'evidenceType': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'evidenceType'
    ]

    def __init__(self, **kwargs):
        self.evidenceType = kwargs.get(
            'evidenceType', None)
        """
        ECO or OBI is recommended
        """


class Experiment(ProtocolElement):
    """
    An experimental preparation of a Sample.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Experiment", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"doc": "", "type": "string", "name":
"recordCreateTime"}, {"doc": "", "type": "string", "name":
"recordUpdateTime"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "runTime"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "molecule"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "strategy"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "selection"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"library"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "libraryLayout"}, {"doc": "", "type": ["null", "string"],
"name": "instrumentModel"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "instrumentDataFile"}, {"doc": "", "type":
["null", "string"], "name": "sequencingCenter"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "platformUnit"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "instrumentModel",
        "recordCreateTime",
        "recordUpdateTime",
        "sequencingCenter",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'instrumentDataFile',
        'instrumentModel', 'library', 'libraryLayout', 'molecule',
        'name', 'platformUnit', 'recordCreateTime',
        'recordUpdateTime', 'runTime', 'selection',
        'sequencingCenter', 'strategy'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A description of the experiment.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The experiment UUID. This is globally unique.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional experiment information.
        """
        self.instrumentDataFile = kwargs.get(
            'instrumentDataFile', None)
        """
        The data file generated by the instrument.   TODO: This isn't
        actually a file is it?   Should this be instrumentData
        instead?
        """
        self.instrumentModel = kwargs.get(
            'instrumentModel', None)
        """
        The instrument model used as part of this experiment.     This
        maps to sequencing technology in BAM.
        """
        self.library = kwargs.get(
            'library', None)
        """
        The name of the library used as part of this experiment.
        """
        self.libraryLayout = kwargs.get(
            'libraryLayout', None)
        """
        The configuration of sequenced reads. (e.g. Single or Paired)
        """
        self.molecule = kwargs.get(
            'molecule', None)
        """
        The molecule examined in this experiment. (e.g. genomics DNA,
        total RNA)
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the experiment.
        """
        self.platformUnit = kwargs.get(
            'platformUnit', None)
        """
        The platform unit used as part of this experiment. This is a
        flowcell-barcode   or slide unique identifier.
        """
        self.recordCreateTime = kwargs.get(
            'recordCreateTime', None)
        """
        The time at which this record was created.    Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.recordUpdateTime = kwargs.get(
            'recordUpdateTime', None)
        """
        The time at which this record was last updated.   Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.runTime = kwargs.get(
            'runTime', None)
        """
        The time at which this experiment was performed.   Granularity
        here is variabel (e.g. date only).   Format: ISO 8601, YYYY-
        MM-DDTHH:MM:SS (e.g. 2015-02-10T00:03:42)
        """
        self.selection = kwargs.get(
            'selection', None)
        """
        The method used to enrich the target. (e.g.
        immunoprecipitation, size   fractionation, MNase digestion)
        """
        self.sequencingCenter = kwargs.get(
            'sequencingCenter', None)
        """
        The sequencing center used as part of this experiment.
        """
        self.strategy = kwargs.get(
            'strategy', None)
        """
        The experiment technique or strategy applied to the sample.
        (e.g. whole genome sequencing, RNA-seq, RIP-seq)
        """


class ExternalIdentifier(ProtocolElement):
    """
    Identifier from a public database
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ExternalIdentifier", "fields": [{"doc": "", "type": "string", "name":
"database"}, {"doc": "", "type": "string", "name": "identifier"},
{"doc": "", "type": "string", "name": "version"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "database",
        "identifier",
        "version",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'database', 'identifier', 'version'
    ]

    def __init__(self, **kwargs):
        self.database = kwargs.get(
            'database', None)
        """
        The source of the identifier.   (e.g. Ensembl)
        """
        self.identifier = kwargs.get(
            'identifier', None)
        """
        The ID defined by the external database.   (e.g.
        ENST00000000000)
        """
        self.version = kwargs.get(
            'version', None)
        """
        The version of the object or the database   (e.g. 78)
        """


class ExternalIdentifierQuery(ProtocolElement):
    """
    One or more ids can be queried together.  Generally used for
    instances of a particular class of object (e.g. a specific gene or
    SNP).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ExternalIdentifierQuery", "fields": [{"type": {"items": {"namespace":
"org.ga4gh.models", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}], "doc": ""}, "type": "array"}, "name":
"ids"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "ids",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'ids': ExternalIdentifier,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'ids': ExternalIdentifier,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'ids'
    ]

    def __init__(self, **kwargs):
        self.ids = kwargs.get(
            'ids', None)
        """
        No documentation
        """


class Feature(ProtocolElement):
    """
    Node in the annotation graph that annotates a contiguous region of
    a   sequence.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Feature",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": {"items": "string", "type": "array"}, "name": "parentIds"},
{"doc": "", "type": "string", "name": "featureSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "referenceName"},
{"default": null, "type": ["null", "long"], "name": "start"},
{"default": null, "type": ["null", "long"], "name": "end"},
{"default": null, "doc": "", "type": ["null", {"symbols":
["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum", "name":
"Strand"}], "name": "strand"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "ontologySource"}, {"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}, "name": "featureType"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Attributes", "fields":
[{"default": {}, "type": {"values": {"items": ["string", {"doc": "",
"type": "record", "name": "ExternalIdentifier", "fields": [{"doc": "",
"type": "string", "name": "database"}, {"doc": "", "type": "string",
"name": "identifier"}, {"doc": "", "type": "string", "name":
"version"}]}, "OntologyTerm"], "type": "array"}, "type": "map"},
"name": "vals"}]}, "name": "attributes"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "featureSetId",
        "featureType",
        "id",
        "parentIds",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'end', 'featureSetId', 'featureType', 'id',
        'parentIds', 'referenceName', 'start', 'strand'
    ]

    def __init__(self, **kwargs):
        self.attributes = kwargs.get(
            'attributes', None)
        """
        Name/value attributes of the annotation.  Attribute names
        follow the GFF3     naming convention of reserved names
        starting with an upper cases     character, and user-define
        names start with lower-case.  Most GFF3     pre-defined
        attributes apply, the exceptions are ID and Parent, which are
        defined as fields. Additional, the following attributes are
        added:     * Score - the GFF3 score column     * Phase - the
        GFF3 phase column for CDS features.
        """
        self.end = kwargs.get(
            'end', None)
        """
        No documentation
        """
        self.featureSetId = kwargs.get(
            'featureSetId', None)
        """
        Identifier for the containing feature set.
        """
        self.featureType = kwargs.get(
            'featureType', None)
        """
        Feature that is annotated by this region.  Normally, this will
        be a term in     the Sequence Ontology.
        """
        self.id = kwargs.get(
            'id', None)
        """
        Id of this annotation node.
        """
        self.parentIds = kwargs.get(
            'parentIds', None)
        """
        Ids of the parents of this annotation node.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        Genomic location.          All three of referenceName, start,
        and end must be specified as a     group.
        """
        self.start = kwargs.get(
            'start', None)
        """
        No documentation
        """
        self.strand = kwargs.get(
            'strand', None)
        """
        Strand of the feature, or null if unstranded
        """


class FeaturePhenotypeAssociation(ProtocolElement):
    """
    An association between one or more genomic features and a
    phenotype. The instance of association allows us to link a feature
    to a phenotype, multiple times, each bearing potentially different
    levels of confidence, such as resulting from alternative
    experiments and analysis.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"FeaturePhenotypeAssociation", "fields": [{"type": "string", "name":
"id"}, {"doc": "", "type": {"items": {"doc": "", "type": "record",
"name": "Feature", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": {"items": "string", "type": "array"},
"name": "parentIds"}, {"doc": "", "type": "string", "name":
"featureSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"default": null, "type":
["null", "long"], "name": "start"}, {"default": null, "type": ["null",
"long"], "name": "end"}, {"default": null, "doc": "", "type": ["null",
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}], "name": "strand"}, {"doc": "", "type": {"doc": "",
"type": "record", "name": "OntologyTerm", "fields": [{"doc": "",
"type": "string", "name": "ontologySource"}, {"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}, "name": "featureType"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Attributes", "fields":
[{"default": {}, "type": {"values": {"items": ["string", {"doc": "",
"type": "record", "name": "ExternalIdentifier", "fields": [{"doc": "",
"type": "string", "name": "database"}, {"doc": "", "type": "string",
"name": "identifier"}, {"doc": "", "type": "string", "name":
"version"}]}, "OntologyTerm"], "type": "array"}, "type": "map"},
"name": "vals"}]}, "name": "attributes"}]}, "type": "array"}, "name":
"features"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Evidence", "fields": [{"doc": "", "type":
"OntologyTerm", "name": "evidenceType"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}]}, "type":
"array"}, "name": "evidence"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "PhenotypeInstance", "fields": [{"doc": "", "type":
["null", "string"], "name": "id"}, {"doc": "", "type": "OntologyTerm",
"name": "type"}, {"default": null, "doc": "", "type": ["null",
{"items": "OntologyTerm", "type": "array"}], "name": "qualifier"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"ageOfOnset"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}]}, "name": "phenotype"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"EnvironmentalContext", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "id"}, {"doc": "", "type":
"OntologyTerm", "name": "environmentType"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "description"}]}, "type":
"array"}, "name": "environmentalContexts"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "environmentalContexts",
        "evidence",
        "features",
        "id",
        "phenotype",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'environmentalContexts': EnvironmentalContext,
            'evidence': Evidence,
            'features': Feature,
            'phenotype': PhenotypeInstance,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'environmentalContexts': EnvironmentalContext,
            'evidence': Evidence,
            'features': Feature,
            'phenotype': PhenotypeInstance,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'environmentalContexts', 'evidence',
        'features', 'id', 'phenotype'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A textual description of the association.
        """
        self.environmentalContexts = kwargs.get(
            'environmentalContexts', None)
        """
        The context in which the phenotype arises.   Multiple contexts
        can be specified - these are assumed to all hold together
        """
        self.evidence = kwargs.get(
            'evidence', None)
        """
        The evidence for this specific instance of association between
        the     features and the phenotype.
        """
        self.features = kwargs.get(
            'features', None)
        """
        The set of features of the organism that bears the phenotype.
        This could be as complete as a full complement of variants,
        or as minimal as the confirmed variants that are known
        causation     for the annotated phenotype.       Examples of
        features could be variations at the nucleotide level,
        large rearrangements at the chromosome level, or relevant
        epigenetic     markers.  Relevant genomic feature types are
        suggested to be      those typed in the Sequence Ontology
        (SO).      The feature set can have only one item, and must
        not be null.
        """
        self.id = kwargs.get(
            'id', None)
        """
        No documentation
        """
        self.phenotype = kwargs.get(
            'phenotype', None)
        """
        The phenotypic component of this association.     Note that we
        delegate this to a separate record to allow us the flexibility
        to composition of phenotype associations with records that are
        not          variant sets - for example, diseases.
        """


class FeatureSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"FeatureSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"doc": "", "type": ["null", "string"], "name":
"referenceSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceURI"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "Attributes", "fields": [{"default": {},
"type": {"values": {"items": ["string", {"doc": "", "type": "record",
"name": "ExternalIdentifier", "fields": [{"doc": "", "type": "string",
"name": "database"}, {"doc": "", "type": "string", "name":
"identifier"}, {"doc": "", "type": "string", "name": "version"}]},
{"doc": "", "type": "record", "name": "OntologyTerm", "fields":
[{"doc": "", "type": "string", "name": "ontologySource"}, {"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}]}], "type": "array"}, "type":
"map"}, "name": "vals"}]}, "name": "attributes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'datasetId', 'id', 'name', 'referenceSetId',
        'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.attributes = kwargs.get(
            'attributes', None)
        """
        Set of additional attributes
        """
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this annotation set belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The ID of this annotation set.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The display name for this annotation set.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The ID of the reference set which defines the coordinate-space
        for this     set of annotations.
        """
        self.sourceURI = kwargs.get(
            'sourceURI', None)
        """
        The source URI describing the file from which this annotation
        set was     generated, if any.
        """


class Fragment(ProtocolElement):
    """
    A fragment represents a contiguous stretch of a DNA or RNA
    molecule. Reads can be associated with a fragment to specify they
    derive from the same molecule.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Fragment", "fields": [{"doc": "", "type": "string", "name": "id"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        The fragment ID.
        """


class GAException(ProtocolElement):
    """
    A general exception type.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "error", "name":
"GAException", "fields": [{"doc": "", "type": "string", "name":
"message"}, {"default": -1, "doc": "", "type": "int", "name":
"errorCode"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "message",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'errorCode', 'message'
    ]

    def __init__(self, **kwargs):
        self.errorCode = kwargs.get(
            'errorCode', -1)
        """
        The numerical error code
        """
        self.message = kwargs.get(
            'message', None)
        """
        The error message
        """


class GenomicFeatureQuery(ProtocolElement):
    """
    The feature collection to search for.  One or more features
    (variants, genes, etc) can be specified.  The idea here is that if
    a query is for a gene, then any alleles to that gene for which
    there are annotation records would be returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"GenomicFeatureQuery", "fields": [{"type": {"items": {"namespace":
"org.ga4gh.models", "type": "record", "name": "Feature", "fields":
[{"doc": "", "type": "string", "name": "id"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "parentIds"}, {"doc":
"", "type": "string", "name": "featureSetId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"default": null, "type": ["null", "long"], "name": "start"},
{"default": null, "type": ["null", "long"], "name": "end"},
{"default": null, "doc": "", "type": ["null", {"symbols":
["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum", "name":
"Strand"}], "name": "strand"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "ontologySource"}, {"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}, "name": "featureType"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Attributes", "fields":
[{"default": {}, "type": {"values": {"items": ["string", {"doc": "",
"type": "record", "name": "ExternalIdentifier", "fields": [{"doc": "",
"type": "string", "name": "database"}, {"doc": "", "type": "string",
"name": "identifier"}, {"doc": "", "type": "string", "name":
"version"}]}, "OntologyTerm"], "type": "array"}, "type": "map"},
"name": "vals"}]}, "name": "attributes"}], "doc": ""}, "type":
"array"}, "name": "features"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "features",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'features'
    ]

    def __init__(self, **kwargs):
        self.features = kwargs.get(
            'features', None)
        """
        No documentation
        """


class LinearAlignment(ProtocolElement):
    """
    A linear alignment can be represented by one CIGAR string.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"LinearAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Position", "fields": [{"doc": "", "type": "string",
"name": "referenceName"}, {"doc": "", "type": "long", "name":
"position"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "position"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "CigarUnit",
"fields": [{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH",
"INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "", "type": "enum",
"name": "CigarOperation"}, "name": "operation"}, {"doc": "", "type":
"long", "name": "operationLength"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSequence"}]}, "type":
"array"}, "name": "cigar"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'cigar', 'mappingQuality', 'position'
    ]

    def __init__(self, **kwargs):
        self.cigar = kwargs.get(
            'cigar', [])
        """
        Represents the local alignment of this sequence (alignment
        matches, indels, etc)   versus the reference.
        """
        self.mappingQuality = kwargs.get(
            'mappingQuality', None)
        """
        The mapping quality of this alignment. Represents how likely
        the read maps to this position as opposed to other locations.
        """
        self.position = kwargs.get(
            'position', None)
        """
        The position of this alignment.
        """


class ListReferenceBasesRequest(ProtocolElement):
    """
    The query parameters for a request to GET /references/{id}/bases,
    for example:  GET /references/{id}/bases?start=100&end=200
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesRequest", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "start"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "end"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageToken', 'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        The end position (0-based, exclusive) of this query. Defaults
        to the length of this Reference.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.start = kwargs.get(
            'start', 0)
        """
        The start position (0-based) of this query. Defaults to 0.
        Genomic positions are non-negative integers less than
        reference length.   Requests spanning the join of circular
        genomes are represented as   two requests one on each side of
        the join (position 0).
        """


class ListReferenceBasesResponse(ProtocolElement):
    """
    The response from GET /references/{id}/bases expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesResponse", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "offset"}, {"doc": "", "type": "string",
"name": "sequence"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "sequence",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'offset', 'sequence'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.offset = kwargs.get(
            'offset', 0)
        """
        The offset position (0-based) of the given sequence from the
        start of this   Reference. This value will differ for each
        page in a paginated request.
        """
        self.sequence = kwargs.get(
            'sequence', None)
        """
        A substring of the bases that make up this reference. Bases
        are represented   as IUPAC-IUB codes; this string matches the
        regexp [ACGTMRWSYKVHDBN]*.
        """


class OntologyTerm(ProtocolElement):
    """
    An ontology term describing an attribute. (e.g. the phenotype
    attribute   'polydactyly' from HPO)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "ontologySource",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'name', 'ontologySource'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        The ID defined by the external onotology source.     (e.g.
        http://purl.obolibrary.org/obo/OBI_0001271)
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the onotology term. (e.g. RNA-seq assay)
        """
        self.ontologySource = kwargs.get(
            'ontologySource', None)
        """
        The source of the onotology term.     (e.g. Ontology for
        Biomedical Investigation)
        """


class OntologyTermQuery(ProtocolElement):
    """
    One or more ontology terms can be queried together.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"OntologyTermQuery", "fields": [{"type": {"items": {"namespace":
"org.ga4gh.models", "type": "record", "name": "OntologyTerm",
"fields": [{"doc": "", "type": "string", "name": "ontologySource"},
{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}], "doc": ""}, "type":
"array"}, "name": "terms"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "terms",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'terms': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'terms': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'terms'
    ]

    def __init__(self, **kwargs):
        self.terms = kwargs.get(
            'terms', None)
        """
        No documentation
        """


class PhenotypeInstance(ProtocolElement):
    """
    An association to a phenotype and related information. This record
    is intended primarily to be used in conjunction with variants, but
    the record can also be composed with other kinds of entities such
    as diseases
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"PhenotypeInstance", "fields": [{"doc": "", "type": ["null",
"string"], "name": "id"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "ontologySource"}, {"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}, "name": "type"}, {"default": null,
"doc": "", "type": ["null", {"items": "OntologyTerm", "type":
"array"}], "name": "qualifier"}, {"default": null, "doc": "", "type":
["null", "OntologyTerm"], "name": "ageOfOnset"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "description"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "type",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'ageOfOnset': OntologyTerm,
            'type': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'ageOfOnset': OntologyTerm,
            'type': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'ageOfOnset', 'description', 'id', 'qualifier', 'type'
    ]

    def __init__(self, **kwargs):
        self.ageOfOnset = kwargs.get(
            'ageOfOnset', None)
        """
        HPO is recommended, for example, subclasses of
        http://purl.obolibrary.org/obo/HP_0011007
        """
        self.description = kwargs.get(
            'description', None)
        """
        A textual description of the phenotype. This is used to
        complement the    structured phenotype description in the type
        field.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The Phenotype ID.
        """
        self.qualifier = kwargs.get(
            'qualifier', None)
        """
        PATO is recommended.  Often this qualifier might be for
        abnormal/normal,    or severity.   For example, severe:
        http://purl.obolibrary.org/obo/PATO_0000396    or abnormal:
        http://purl.obolibrary.org/obo/PATO_0000460
        """
        self.type = kwargs.get(
            'type', None)
        """
        HPO is recommended
        """


class PhenotypeQuery(ProtocolElement):
    """
    One or more phenotypes can be queried together.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"PhenotypeQuery", "fields": [{"type": {"items": {"namespace":
"org.ga4gh.models", "type": "record", "name": "PhenotypeInstance",
"fields": [{"doc": "", "type": ["null", "string"], "name": "id"},
{"doc": "", "type": {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}]}, "name": "type"}, {"default": null, "doc": "", "type":
["null", {"items": "OntologyTerm", "type": "array"}], "name":
"qualifier"}, {"default": null, "doc": "", "type": ["null",
"OntologyTerm"], "name": "ageOfOnset"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}], "doc": ""},
"type": "array"}, "name": "phenotypes"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "phenotypes",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'phenotypes': PhenotypeInstance,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'phenotypes': PhenotypeInstance,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'phenotypes'
    ]

    def __init__(self, **kwargs):
        self.phenotypes = kwargs.get(
            'phenotypes', None)
        """
        No documentation
        """


class Position(ProtocolElement):
    """
    A Position is an unoriented base in some Reference. A Position is
    represented by a Reference name, and a base number on that
    Reference (0-based).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Position", "fields": [{"doc": "", "type": "string", "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc":
"", "type": "enum", "name": "Strand"}, "name": "strand"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
        "referenceName",
        "strand",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'position', 'referenceName', 'strand'
    ]

    def __init__(self, **kwargs):
        self.position = kwargs.get(
            'position', None)
        """
        The 0-based offset from the start of the forward strand for
        that Reference.   Genomic positions are non-negative integers
        less than Reference length.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The name of the Reference on which the Position is located.
        """
        self.strand = kwargs.get(
            'strand', None)
        """
        Strand the position is associated with.
        """


class Program(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Program",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "commandLine"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "prevProgramId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "version"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'commandLine', 'id', 'name', 'prevProgramId', 'version'
    ]

    def __init__(self, **kwargs):
        self.commandLine = kwargs.get(
            'commandLine', None)
        """
        The command line used to run this program.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The user specified ID of the program.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the program.
        """
        self.prevProgramId = kwargs.get(
            'prevProgramId', None)
        """
        The ID of the program run before this one.
        """
        self.version = kwargs.get(
            'version', None)
        """
        The version of the program run.
        """


class ReadAlignment(ProtocolElement):
    """
    Each read alignment describes an alignment with additional
    information about the fragment and the read. A read alignment
    object is equivalent to a line in a SAM file.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentId"}, {"doc": "",
"type": "string", "name": "fragmentName"}, {"default": null, "doc":
"", "type": ["null", "boolean"], "name": "properPlacement"},
{"default": null, "doc": "", "type": ["null", "boolean"], "name":
"duplicateFragment"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "numberReads"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "fragmentLength"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "readNumber"}, {"default": null,
"doc": "", "type": ["null", "boolean"], "name":
"failedVendorQualityChecks"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "LinearAlignment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Position", "fields": [{"doc": "", "type": "string", "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc":
"", "type": "enum", "name": "Strand"}, "name": "strand"}]}, "name":
"position"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "mappingQuality"}, {"default": [], "doc": "", "type":
{"items": {"doc": "", "type": "record", "name": "CigarUnit", "fields":
[{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH", "INSERT",
"DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD", "SEQUENCE_MATCH",
"SEQUENCE_MISMATCH"], "doc": "", "type": "enum", "name":
"CigarOperation"}, "name": "operation"}, {"doc": "", "type": "long",
"name": "operationLength"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceSequence"}]}, "type": "array"},
"name": "cigar"}]}], "name": "alignment"}, {"default": null, "doc":
"", "type": ["null", "boolean"], "name": "secondaryAlignment"},
{"default": null, "doc": "", "type": ["null", "boolean"], "name":
"supplementaryAlignment"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "alignedSequence"}, {"default": [], "doc":
"", "type": {"items": "int", "type": "array"}, "name":
"alignedQuality"}, {"default": null, "doc": "", "type": ["null",
"Position"], "name": "nextMatePosition"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "fragmentId",
        "fragmentName",
        "id",
        "readGroupId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedQuality', 'alignedSequence', 'alignment',
        'duplicateFragment', 'failedVendorQualityChecks',
        'fragmentId', 'fragmentLength', 'fragmentName', 'id', 'info',
        'nextMatePosition', 'numberReads', 'properPlacement',
        'readGroupId', 'readNumber', 'secondaryAlignment',
        'supplementaryAlignment'
    ]

    def __init__(self, **kwargs):
        self.alignedQuality = kwargs.get(
            'alignedQuality', [])
        """
        The quality of the read sequence contained in this alignment
        record.   alignedSequence and alignedQuality may be shorter
        than the full read sequence   and quality. This will occur if
        the alignment is part of a chimeric alignment,   or if the
        read was trimmed. When this occurs, the CIGAR for this read
        will   begin/end with a hard clip operator that will indicate
        the length of the excised sequence.
        """
        self.alignedSequence = kwargs.get(
            'alignedSequence', None)
        """
        The bases of the read sequence contained in this alignment
        record.   alignedSequence and alignedQuality may be shorter
        than the full read sequence   and quality. This will occur if
        the alignment is part of a chimeric alignment,   or if the
        read was trimmed. When this occurs, the CIGAR for this read
        will   begin/end with a hard clip operator that will indicate
        the length of the excised sequence.
        """
        self.alignment = kwargs.get(
            'alignment', None)
        """
        The alignment for this alignment record. This field will be
        null if the read   is unmapped.
        """
        self.duplicateFragment = kwargs.get(
            'duplicateFragment', None)
        """
        The fragment is a PCR or optical duplicate (SAM flag 0x400)
        """
        self.failedVendorQualityChecks = kwargs.get(
            'failedVendorQualityChecks', None)
        """
        SAM flag 0x200
        """
        self.fragmentId = kwargs.get(
            'fragmentId', None)
        """
        The fragment ID that this ReadAlignment belongs to.
        """
        self.fragmentLength = kwargs.get(
            'fragmentLength', None)
        """
        The observed length of the fragment, equivalent to TLEN in
        SAM.
        """
        self.fragmentName = kwargs.get(
            'fragmentName', None)
        """
        The fragment name. Equivalent to QNAME (query template name)
        in SAM.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The read alignment ID. This ID is unique within the read group
        this   alignment belongs to. This field may not be provided by
        all backends.   Its intended use is to make caching and UI
        display easier for   genome browsers and other light weight
        clients.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional read alignment information.
        """
        self.nextMatePosition = kwargs.get(
            'nextMatePosition', None)
        """
        The mapping of the primary alignment of the
        (readNumber+1)%numberReads   read in the fragment. It replaces
        mate position and mate strand in SAM.
        """
        self.numberReads = kwargs.get(
            'numberReads', None)
        """
        The number of reads in the fragment (extension to SAM flag
        0x1)
        """
        self.properPlacement = kwargs.get(
            'properPlacement', None)
        """
        The orientation and the distance between reads from the
        fragment are   consistent with the sequencing protocol
        (equivalent to SAM flag 0x2)
        """
        self.readGroupId = kwargs.get(
            'readGroupId', None)
        """
        The ID of the read group this read belongs to.   (Every read
        must belong to exactly one read group.)
        """
        self.readNumber = kwargs.get(
            'readNumber', None)
        """
        The read number in sequencing. 0-based and less than
        numberReads. This field   replaces SAM flag 0x40 and 0x80.
        """
        self.secondaryAlignment = kwargs.get(
            'secondaryAlignment', None)
        """
        Whether this alignment is secondary. Equivalent to SAM flag
        0x100.   A secondary alignment represents an alternative to
        the primary alignment   for this read. Aligners may return
        secondary alignments if a read can map   ambiguously to
        multiple coordinates in the genome.    By convention, each
        read has one and only one alignment where both
        secondaryAlignment and supplementaryAlignment are false.
        """
        self.supplementaryAlignment = kwargs.get(
            'supplementaryAlignment', None)
        """
        Whether this alignment is supplementary. Equivalent to SAM
        flag 0x800.   Supplementary alignments are used in the
        representation of a chimeric   alignment. In a chimeric
        alignment, a read is split into multiple   linear alignments
        that map to different reference contigs. The first   linear
        alignment in the read will be designated as the representative
        alignment;   the remaining linear alignments will be
        designated as supplementary alignments.   These alignments may
        have different mapping quality scores.    In each linear
        alignment in a chimeric alignment, the read will be hard
        clipped.   The alignedSequence and alignedQuality fields in
        the alignment record will   only represent the bases for its
        respective linear alignment.
        """


class ReadGroup(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroup", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"doc": "", "type": ["null",
"string"], "name": "sampleId"}, {"doc": "", "type": ["null", {"doc":
"", "type": "record", "name": "Experiment", "fields": [{"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": "string", "name": "recordCreateTime"}, {"doc": "", "type":
"string", "name": "recordUpdateTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "runTime"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "molecule"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strategy"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "selection"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "library"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "libraryLayout"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "instrumentDataFile"},
{"doc": "", "type": ["null", "string"], "name": "sequencingCenter"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}], "name": "experiment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "predictedInsertSize"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "created"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"updated"}, {"default": null, "doc": "", "type": ["null", {"fields":
[{"default": null, "doc": "", "type": ["null", "long"], "name":
"alignedReadCount"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "unalignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "baseCount"}], "type": "record",
"name": "ReadStats"}], "name": "stats"}, {"default": [], "doc": "",
"type": {"items": {"fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "commandLine"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "id"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "prevProgramId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"version"}], "type": "record", "name": "Program"}, "type": "array"},
"name": "programs"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceSetId"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "experiment",
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'datasetId', 'description', 'experiment', 'id',
        'info', 'name', 'predictedInsertSize', 'programs',
        'referenceSetId', 'sampleId', 'stats', 'updated'
    ]

    def __init__(self, **kwargs):
        self.created = kwargs.get(
            'created', None)
        """
        The time at which this read group was created in milliseconds
        from the epoch.
        """
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this read group belongs to.
        """
        self.description = kwargs.get(
            'description', None)
        """
        The read group description.
        """
        self.experiment = kwargs.get(
            'experiment', None)
        """
        The experiment used to generate this read group.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The read group ID.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional read group information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The read group name.
        """
        self.predictedInsertSize = kwargs.get(
            'predictedInsertSize', None)
        """
        The predicted insert size of this read group.
        """
        self.programs = kwargs.get(
            'programs', [])
        """
        The programs used to generate this read group.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The reference set the reads in this read group are aligned to.
        Required if there are any read alignments.
        """
        self.sampleId = kwargs.get(
            'sampleId', None)
        """
        The sample this read group's data was generated from.
        """
        self.stats = kwargs.get(
            'stats', None)
        """
        Statistical data on reads in this read group.
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this read group was last updated in
        milliseconds   from the epoch.
        """


class ReadGroupSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroupSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", {"fields": [{"default": null, "doc": "", "type": ["null",
"long"], "name": "alignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "unalignedReadCount"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "baseCount"}],
"type": "record", "name": "ReadStats"}], "name": "stats"}, {"default":
[], "doc": "", "type": {"items": {"fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": ["null", "string"], "name": "sampleId"}, {"doc": "", "type":
["null", {"doc": "", "type": "record", "name": "Experiment", "fields":
[{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "description"}, {"doc":
"", "type": "string", "name": "recordCreateTime"}, {"doc": "", "type":
"string", "name": "recordUpdateTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "runTime"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "molecule"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strategy"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "selection"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "library"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "libraryLayout"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "instrumentDataFile"},
{"doc": "", "type": ["null", "string"], "name": "sequencingCenter"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}], "name": "experiment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "predictedInsertSize"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "created"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"updated"}, {"default": null, "doc": "", "type": ["null",
"ReadStats"], "name": "stats"}, {"default": [], "doc": "", "type":
{"items": {"fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "commandLine"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "prevProgramId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"version"}], "type": "record", "name": "Program"}, "type": "array"},
"name": "programs"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceSetId"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "type": "record", "name": "ReadGroup"},
"type": "array"}, "name": "readGroups"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'name', 'readGroups', 'stats'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this read group set belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The read group set ID.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The read group set name.
        """
        self.readGroups = kwargs.get(
            'readGroups', [])
        """
        The read groups in this set.
        """
        self.stats = kwargs.get(
            'stats', None)
        """
        Statistical data on reads in this read group set.
        """


class ReadStats(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadStats", "fields": [{"default": null, "doc": "", "type": ["null",
"long"], "name": "alignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "unalignedReadCount"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "baseCount"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedReadCount', 'baseCount', 'unalignedReadCount'
    ]

    def __init__(self, **kwargs):
        self.alignedReadCount = kwargs.get(
            'alignedReadCount', None)
        """
        The number of aligned reads.
        """
        self.baseCount = kwargs.get(
            'baseCount', None)
        """
        The total number of bases.   This is equivalent to the sum of
        alignedSequence.length for all reads.
        """
        self.unalignedReadCount = kwargs.get(
            'unalignedReadCount', None)
        """
        The number of unaligned reads.
        """


class Reference(ProtocolElement):
    """
    A Reference is a canonical assembled contig, intended to act as a
    reference coordinate space for other genomic annotations. A single
    Reference might represent the human chromosome 1, for instance.
    Reference's are designed to be immutable.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Reference", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "long", "name": "length"}, {"doc": "", "type":
"string", "name": "md5checksum"}, {"doc": "", "type": "string",
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sourceURI"}, {"doc": "", "type": {"items":
"string", "type": "array"}, "name": "sourceAccessions"}, {"default":
false, "doc": "", "type": "boolean", "name": "isDerived"}, {"default":
null, "doc": "", "type": ["null", "float"], "name":
"sourceDivergence"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "ncbiTaxonId"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "length",
        "md5checksum",
        "name",
        "sourceAccessions",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'isDerived', 'length', 'md5checksum', 'name',
        'ncbiTaxonId', 'sourceAccessions', 'sourceDivergence',
        'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        The reference ID. Unique within the repository.
        """
        self.isDerived = kwargs.get(
            'isDerived', False)
        """
        A sequence X is said to be derived from source sequence Y, if
        X and Y   are of the same length and the per-base sequence
        divergence at A/C/G/T bases   is sufficiently small. Two
        sequences derived from the same official   sequence share the
        same coordinates and annotations, and   can be replaced with
        the official sequence for certain use cases.
        """
        self.length = kwargs.get(
            'length', None)
        """
        The length of this reference's sequence.
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        The MD5 checksum uniquely representing this Reference as a
        lower-case   hexadecimal string, calculated as the MD5 of the
        upper-case sequence   excluding all whitespace characters
        (this is equivalent to SQ:M5 in SAM).
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of this reference. (e.g. '22').
        """
        self.ncbiTaxonId = kwargs.get(
            'ncbiTaxonId', None)
        """
        ID from http://www.ncbi.nlm.nih.gov/taxonomy (e.g.
        9606->human).
        """
        self.sourceAccessions = kwargs.get(
            'sourceAccessions', None)
        """
        All known corresponding accession IDs in INSDC
        (GenBank/ENA/DDBJ) which must include   a version number, e.g.
        GCF_000001405.26.
        """
        self.sourceDivergence = kwargs.get(
            'sourceDivergence', None)
        """
        The sourceDivergence is the fraction of non-indel bases that
        do not match the   reference this record was derived from.
        """
        self.sourceURI = kwargs.get(
            'sourceURI', None)
        """
        The URI from which the sequence was obtained. Specifies a
        FASTA format   file/string with one name, sequence pair. In
        most cases, clients should call   the getReferenceBases()
        method to obtain sequence bases for a Reference   instead of
        attempting to retrieve this URI.
        """


class ReferenceSet(ProtocolElement):
    """
    A ReferenceSet is a set of References which typically comprise a
    reference assembly, such as GRCh38. A ReferenceSet defines a
    common coordinate space for comparing reference-aligned
    experimental data.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReferenceSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"doc": "", "type": "string", "name": "md5checksum"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "md5checksum",
        "sourceAccessions",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'assemblyId', 'description', 'id', 'isDerived', 'md5checksum',
        'name', 'ncbiTaxonId', 'sourceAccessions', 'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.assemblyId = kwargs.get(
            'assemblyId', None)
        """
        Public id of this reference set, such as GRCh37.
        """
        self.description = kwargs.get(
            'description', None)
        """
        Optional free text description of this reference set.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The reference set ID. Unique in the repository.
        """
        self.isDerived = kwargs.get(
            'isDerived', False)
        """
        A reference set may be derived from a source if it contains
        additional sequences, or some of the sequences within it are
        derived   (see the definition of isDerived in Reference).
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        Order-independent MD5 checksum which identifies this
        ReferenceSet.    To compute this checksum, make a list of
        Reference.md5checksum for all   References in this set. Then
        sort that list, and take the MD5 hash of   all the strings
        concatenated together. Express the hash as a lower-case
        hexadecimal string.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The reference set name.
        """
        self.ncbiTaxonId = kwargs.get(
            'ncbiTaxonId', None)
        """
        ID from http://www.ncbi.nlm.nih.gov/taxonomy (e.g.
        9606->human) indicating   the species which this assembly is
        intended to model. Note that contained   References may
        specify a different ncbiTaxonId, as assemblies may   contain
        reference sequences which do not belong to the modeled
        species, e.g.   EBV in a human reference genome.
        """
        self.sourceAccessions = kwargs.get(
            'sourceAccessions', None)
        """
        All known corresponding accession IDs in INSDC
        (GenBank/ENA/DDBJ) ideally   with a version number, e.g.
        NC_000001.11.
        """
        self.sourceURI = kwargs.get(
            'sourceURI', None)
        """
        Specifies a FASTA format file/string.
        """


class SearchCallSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /callsets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "variantSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.name = kwargs.get(
            'name', None)
        """
        Only return call sets with this name (case-sensitive, exact
        match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The VariantSet to search.
        """


class SearchCallSetsResponse(SearchResponse):
    """
    This is the response from POST /callsets/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "CallSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"doc": "", "type": ["null", "string"], "name":
"sampleId"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "variantSetIds"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "created"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "updated"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}, "type":
"array"}, "name": "callSets"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "callSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSets', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.callSets = kwargs.get(
            'callSets', [])
        """
        The list of matching call sets.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchDatasetsRequest(SearchRequest):
    """
    This request maps to the body of POST /datasets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchDatasetsResponse(SearchResponse):
    """
    This is the response from POST /datasets/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Dataset", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}], "doc": ""}, "type": "array"},
"name": "datasets"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "datasets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasets', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.datasets = kwargs.get(
            'datasets', [])
        """
        The list of datasets.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchGenotypePhenotypeRequest(SearchRequest):
    """
    This request maps to the body of POST /genotypephenotype/search as
    JSON.  The goal here is to allow users to query using one or more
    of Genotype, Phenotype, Environment, and Evidence.  A query using
    one of the above items is to mean, by default, that the remainder
    of the query is as a "wildcard", such that all matches to just
    that query term would come back. Combinations of the above are to
    act like AND rather than OR.  The "genotype" part of the query
    methods can be one or more genomic features.  Associations can be
    made at many levels of granularity (from whole genotypes down to
    individual SNVs), but users may use these methods with partial or
    inexact information.  Therefore, the query methods must be able to
    support query of some or all of the associated features.
    Furthermore, use of the relationships between genomic features
    means that when querying for a gene, any variants to that gene are
    also returned.  For example, a query with BRCA2 would mean that in
    addition to any direct associations to the BRCA2, all associations
    to sequence variants of BRCA2 would also be returned.  Similarly,
    queries with OntologyTerms should perform the subclass closure.
    Each query can be made against a string, an array of external
    identifers (such as for gene or SNP ids), ontology term ids, or
    full feature/phenotype/evidence objects.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchGenotypePhenotypeRequest", "fields": [{"default": null, "type":
["null", "string", {"doc": "", "type": "record", "name":
"ExternalIdentifierQuery", "fields": [{"type": {"items": {"namespace":
"org.ga4gh.models", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}], "doc": ""}, "type": "array"}, "name":
"ids"}]}, {"doc": "", "type": "record", "name": "OntologyTermQuery",
"fields": [{"type": {"items": {"namespace": "org.ga4gh.models",
"type": "record", "name": "OntologyTerm", "fields": [{"doc": "",
"type": "string", "name": "ontologySource"}, {"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}], "doc": ""}, "type": "array"}, "name":
"terms"}]}, {"doc": "", "type": "record", "name":
"GenomicFeatureQuery", "fields": [{"type": {"items": {"namespace":
"org.ga4gh.models", "type": "record", "name": "Feature", "fields":
[{"doc": "", "type": "string", "name": "id"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "parentIds"}, {"doc":
"", "type": "string", "name": "featureSetId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"default": null, "type": ["null", "long"], "name": "start"},
{"default": null, "type": ["null", "long"], "name": "end"},
{"default": null, "doc": "", "type": ["null", {"symbols":
["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum", "name":
"Strand"}], "name": "strand"}, {"doc": "", "type": "OntologyTerm",
"name": "featureType"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "Attributes", "fields": [{"default": {}, "type":
{"values": {"items": ["string", "ExternalIdentifier", "OntologyTerm"],
"type": "array"}, "type": "map"}, "name": "vals"}]}, "name":
"attributes"}], "doc": ""}, "type": "array"}, "name": "features"}]}],
"name": "feature"}, {"default": null, "type": ["null", "string",
"ExternalIdentifierQuery", "OntologyTermQuery", {"doc": "", "type":
"record", "name": "PhenotypeQuery", "fields": [{"type": {"items":
{"namespace": "org.ga4gh.models", "type": "record", "name":
"PhenotypeInstance", "fields": [{"doc": "", "type": ["null",
"string"], "name": "id"}, {"doc": "", "type": "OntologyTerm", "name":
"type"}, {"default": null, "doc": "", "type": ["null", {"items":
"OntologyTerm", "type": "array"}], "name": "qualifier"}, {"default":
null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"ageOfOnset"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}], "doc": ""}, "type": "array"},
"name": "phenotypes"}]}], "name": "phenotype"}, {"default": null,
"type": ["null", "string", "ExternalIdentifierQuery",
"OntologyTermQuery", {"doc": "", "type": "record", "name":
"EvidenceQuery", "fields": [{"doc": "", "type": {"items":
"org.ga4gh.models.OntologyTerm", "type": "array"}, "name":
"evidenceType"}]}], "name": "evidence"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'evidence', 'feature', 'pageSize', 'pageToken', 'phenotype'
    ]

    def __init__(self, **kwargs):
        self.evidence = kwargs.get(
            'evidence', None)
        """
        No documentation
        """
        self.feature = kwargs.get(
            'feature', None)
        """
        No documentation
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.phenotype = kwargs.get(
            'phenotype', None)
        """
        No documentation
        """


class SearchGenotypePhenotypeResponse(SearchResponse):
    """
    This is the response from POST /genotypephenotype/search expressed
    as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchGenotypePhenotypeResponse", "fields": [{"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "FeaturePhenotypeAssociation", "fields": [{"type":
"string", "name": "id"}, {"doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "Feature", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"doc": "", "type": {"items": "string",
"type": "array"}, "name": "parentIds"}, {"doc": "", "type": "string",
"name": "featureSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"default": null, "type":
["null", "long"], "name": "start"}, {"default": null, "type": ["null",
"long"], "name": "end"}, {"default": null, "doc": "", "type": ["null",
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}], "name": "strand"}, {"doc": "", "type": {"doc": "",
"type": "record", "name": "OntologyTerm", "fields": [{"doc": "",
"type": "string", "name": "ontologySource"}, {"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}, "name": "featureType"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Attributes", "fields":
[{"default": {}, "type": {"values": {"items": ["string", {"doc": "",
"type": "record", "name": "ExternalIdentifier", "fields": [{"doc": "",
"type": "string", "name": "database"}, {"doc": "", "type": "string",
"name": "identifier"}, {"doc": "", "type": "string", "name":
"version"}]}, "OntologyTerm"], "type": "array"}, "type": "map"},
"name": "vals"}]}, "name": "attributes"}]}, "type": "array"}, "name":
"features"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Evidence", "fields": [{"doc": "", "type":
"OntologyTerm", "name": "evidenceType"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}]}, "type":
"array"}, "name": "evidence"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "PhenotypeInstance", "fields": [{"doc": "", "type":
["null", "string"], "name": "id"}, {"doc": "", "type": "OntologyTerm",
"name": "type"}, {"default": null, "doc": "", "type": ["null",
{"items": "OntologyTerm", "type": "array"}], "name": "qualifier"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"ageOfOnset"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}]}, "name": "phenotype"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"EnvironmentalContext", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "id"}, {"doc": "", "type":
"OntologyTerm", "name": "environmentType"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "description"}]}, "type":
"array"}, "name": "environmentalContexts"}], "doc": ""}, "type":
"array"}, "name": "associations"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "associations"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'associations': FeaturePhenotypeAssociation,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'associations': FeaturePhenotypeAssociation,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'associations', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.associations = kwargs.get(
            'associations', [])
        """
        The list of matching FeaturePhenotypeAssociation.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchReadGroupSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /readgroupsets/search as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'name', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The dataset to search.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Only return read group sets with this name (case-sensitive,
        exact match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchReadGroupSetsResponse(SearchResponse):
    """
    This is the response from POST /readgroupsets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReadGroupSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", {"fields": [{"default": null, "doc": "", "type":
["null", "long"], "name": "alignedReadCount"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "unalignedReadCount"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"baseCount"}], "type": "record", "name": "ReadStats"}], "name":
"stats"}, {"default": [], "doc": "", "type": {"items": {"fields":
[{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "datasetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"description"}, {"doc": "", "type": ["null", "string"], "name":
"sampleId"}, {"doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "Experiment", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "description"}, {"doc": "", "type":
"string", "name": "recordCreateTime"}, {"doc": "", "type": "string",
"name": "recordUpdateTime"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "runTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "molecule"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "strategy"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"selection"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "library"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "libraryLayout"}, {"doc": "", "type": ["null",
"string"], "name": "instrumentModel"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "instrumentDataFile"}, {"doc": "",
"type": ["null", "string"], "name": "sequencingCenter"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "platformUnit"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}]}], "name":
"experiment"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "predictedInsertSize"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"default": null, "doc":
"", "type": ["null", "ReadStats"], "name": "stats"}, {"default": [],
"doc": "", "type": {"items": {"fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "commandLine"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"prevProgramId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "version"}], "type": "record", "name": "Program"},
"type": "array"}, "name": "programs"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}], "type": "record", "name":
"ReadGroup"}, "type": "array"}, "name": "readGroups"}]}, "type":
"array"}, "name": "readGroupSets"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "readGroupSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'readGroupSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.readGroupSets = kwargs.get(
            'readGroupSets', [])
        """
        The list of matching read group sets.
        """


class SearchReadsRequest(SearchRequest):
    """
    This request maps to the body of POST /reads/search as JSON.  If a
    reference is specified, all queried ReadGroups must be aligned to
    ReferenceSets containing that same Reference. If no reference is
    specified, all ReadGroups must be aligned to the same
    ReferenceSet.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsRequest", "fields": [{"doc": "", "type": {"items":
"string", "type": "array"}, "name": "readGroupIds"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceId"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"start"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "end"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "pageSize"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "readGroupIds",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageSize', 'pageToken', 'readGroupIds', 'referenceId',
        'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        The end position (0-based, exclusive) of this query.   If a
        reference is specified, this defaults to the   reference's
        length.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.readGroupIds = kwargs.get(
            'readGroupIds', None)
        """
        The ReadGroups to search. At least one readGroupId must be
        specified.
        """
        self.referenceId = kwargs.get(
            'referenceId', None)
        """
        The reference to query. Leaving blank returns results from all
        references, including unmapped reads - this could be very
        large.
        """
        self.start = kwargs.get(
            'start', None)
        """
        The start position (0-based) of this query.   If a reference
        is specified, this defaults to 0.   Genomic positions are non-
        negative integers less than reference length.   Requests
        spanning the join of circular genomes are represented as   two
        requests one on each side of the join (position 0).
        """


class SearchReadsResponse(SearchResponse):
    """
    This is the response from POST /reads/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentId"}, {"doc": "",
"type": "string", "name": "fragmentName"}, {"default": null, "doc":
"", "type": ["null", "boolean"], "name": "properPlacement"},
{"default": null, "doc": "", "type": ["null", "boolean"], "name":
"duplicateFragment"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "numberReads"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "fragmentLength"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "readNumber"}, {"default": null,
"doc": "", "type": ["null", "boolean"], "name":
"failedVendorQualityChecks"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "LinearAlignment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Position", "fields": [{"doc": "", "type": "string", "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc":
"", "type": "enum", "name": "Strand"}, "name": "strand"}]}, "name":
"position"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "mappingQuality"}, {"default": [], "doc": "", "type":
{"items": {"doc": "", "type": "record", "name": "CigarUnit", "fields":
[{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH", "INSERT",
"DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD", "SEQUENCE_MATCH",
"SEQUENCE_MISMATCH"], "doc": "", "type": "enum", "name":
"CigarOperation"}, "name": "operation"}, {"doc": "", "type": "long",
"name": "operationLength"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceSequence"}]}, "type": "array"},
"name": "cigar"}]}], "name": "alignment"}, {"default": null, "doc":
"", "type": ["null", "boolean"], "name": "secondaryAlignment"},
{"default": null, "doc": "", "type": ["null", "boolean"], "name":
"supplementaryAlignment"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "alignedSequence"}, {"default": [], "doc":
"", "type": {"items": "int", "type": "array"}, "name":
"alignedQuality"}, {"default": null, "doc": "", "type": ["null",
"Position"], "name": "nextMatePosition"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}, "type": "array"}, "name":
"alignments"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alignments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignments', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.alignments = kwargs.get(
            'alignments', [])
        """
        The list of matching alignment records, sorted by position.
        Unmapped reads, which have no position, are returned last.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchReferenceSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /referencesets/search as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "md5checksum"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "accession"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"assemblyId"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "pageSize"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accession', 'assemblyId', 'md5checksum', 'pageSize',
        'pageToken'
    ]

    def __init__(self, **kwargs):
        self.accession = kwargs.get(
            'accession', None)
        """
        If not null, return the reference sets for which the accession
        matches this string (case-sensitive, exact match).
        """
        self.assemblyId = kwargs.get(
            'assemblyId', None)
        """
        If not null, return the reference sets for which the
        assemblyId   matches this string (case-sensitive, exact
        match).
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        If not null, return the reference sets for which the
        md5checksum matches this string (case-sensitive, exact match).
        See ReferenceSet::md5checksum for details.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchReferenceSetsResponse(SearchResponse):
    """
    This is the response from POST /referencesets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReferenceSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}, "type": "array"}, "name":
"referenceSets"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "referenceSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'referenceSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.referenceSets = kwargs.get(
            'referenceSets', [])
        """
        The list of matching reference sets.
        """


class SearchReferencesRequest(SearchRequest):
    """
    This request maps to the body of POST /references/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesRequest", "fields": [{"doc": "", "type": "string",
"name": "referenceSetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "md5checksum"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "accession"}, {"default":
null, "doc": "", "type": ["null", "int"], "name": "pageSize"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accession', 'md5checksum', 'pageSize', 'pageToken',
        'referenceSetId'
    ]

    def __init__(self, **kwargs):
        self.accession = kwargs.get(
            'accession', None)
        """
        If not null, return the references for which the accession
        matches this string (case-sensitive, exact match).
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        If not null, return the references for which the   md5checksum
        matches this string (case-sensitive, exact match).   See
        ReferenceSet::md5checksum for details.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The ReferenceSet to search.
        """


class SearchReferencesResponse(SearchResponse):
    """
    This is the response from POST /references/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Reference", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "long", "name": "length"}, {"doc": "",
"type": "string", "name": "md5checksum"}, {"doc": "", "type":
"string", "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceURI"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "sourceAccessions"},
{"default": false, "doc": "", "type": "boolean", "name": "isDerived"},
{"default": null, "doc": "", "type": ["null", "float"], "name":
"sourceDivergence"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "ncbiTaxonId"}], "doc": ""}, "type": "array"}, "name":
"references"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "references"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'references'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.references = kwargs.get(
            'references', [])
        """
        The list of matching references.
        """


class SearchVariantSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /variantsets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "pageSize"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The Dataset to search.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchVariantSetsResponse(SearchResponse):
    """
    This is the response from POST /variantsets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "VariantSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"doc": "", "type": "string", "name": "datasetId"},
{"doc": "", "type": "string", "name": "referenceSetId"}, {"default":
[], "doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}, "type": "array"}, "name": "variantSets"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variantSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variantSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.variantSets = kwargs.get(
            'variantSets', [])
        """
        The list of matching variant sets.
        """


class SearchVariantsRequest(SearchRequest):
    """
    This request maps to the body of POST /variants/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsRequest", "fields": [{"doc": "", "type": "string",
"name": "variantSetId"}, {"default": null, "doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "callSetIds"}, {"doc":
"", "type": "string", "name": "referenceName"}, {"doc": "", "type":
"long", "name": "start"}, {"doc": "", "type": "long", "name": "end"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "referenceName",
        "start",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetIds', 'end', 'pageSize', 'pageToken', 'referenceName',
        'start', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.callSetIds = kwargs.get(
            'callSetIds', None)
        """
        Only return variant calls which belong to call sets with these
        IDs.   If an empty array, returns variants without any call
        objects.   If null, returns all variant calls.
        """
        self.end = kwargs.get(
            'end', None)
        """
        Required. The end of the window (0-based, exclusive) for which
        overlapping   variants should be returned.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        Required. Only return variants on this reference.
        """
        self.start = kwargs.get(
            'start', None)
        """
        Required. The beginning of the window (0-based, inclusive) for
        which overlapping variants should be returned.   Genomic
        positions are non-negative integers less than reference
        length.   Requests spanning the join of circular genomes are
        represented as   two requests one on each side of the join
        (position 0).
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The VariantSet to search.
        """


class SearchVariantsResponse(SearchResponse):
    """
    This is the response from POST /variants/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Variant", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "variantSetId"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "names"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"doc": "", "type":
"string", "name": "referenceName"}, {"doc": "", "type": "long",
"name": "start"}, {"doc": "", "type": "long", "name": "end"}, {"doc":
"", "type": "string", "name": "referenceBases"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"alternateBases"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name": "info"},
{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Call", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "callSetName"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "callSetId"},
{"default": [], "doc": "", "type": {"items": "int", "type": "array"},
"name": "genotype"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "phaseset"}, {"default": [], "doc": "", "type":
{"items": "double", "type": "array"}, "name": "genotypeLikelihood"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}]}, "type": "array"},
"name": "calls"}], "doc": ""}, "type": "array"}, "name": "variants"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variants"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variants'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.variants = kwargs.get(
            'variants', [])
        """
        The list of matching variants.   If the callSetId field on the
        returned calls is not present,   the ordering of the call sets
        from a SearchCallSetsRequest   over the parent VariantSet is
        guaranteed to match the ordering   of the calls on each
        Variant. The number of results will also be   the same.
        """


class Strand(object):
    """
    Indicates the DNA strand associate for some data item. *
    NEG_STRAND: The negative (-) strand. * POS_STRAND:  The postive
    (+) strand.
    """
    NEG_STRAND = "NEG_STRAND"
    POS_STRAND = "POS_STRAND"


class Variant(ProtocolElement):
    """
    A Variant represents a change in DNA sequence relative to some
    reference. For example, a variant could represent a SNP or an
    insertion. Variants belong to a VariantSet. This is equivalent to
    a row in VCF.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Variant",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": "string", "name": "variantSetId"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "names"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"doc": "", "type": "string", "name":
"referenceName"}, {"doc": "", "type": "long", "name": "start"},
{"doc": "", "type": "long", "name": "end"}, {"doc": "", "type":
"string", "name": "referenceBases"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name":
"alternateBases"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name": "info"},
{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Call", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "callSetName"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "callSetId"},
{"default": [], "doc": "", "type": {"items": "int", "type": "array"},
"name": "genotype"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "phaseset"}, {"default": [], "doc": "", "type":
{"items": "double", "type": "array"}, "name": "genotypeLikelihood"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}]}, "type": "array"},
"name": "calls"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "id",
        "referenceBases",
        "referenceName",
        "start",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alternateBases', 'calls', 'created', 'end', 'id', 'info',
        'names', 'referenceBases', 'referenceName', 'start',
        'updated', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.alternateBases = kwargs.get(
            'alternateBases', [])
        """
        The bases that appear instead of the reference bases. Multiple
        alternate   alleles are possible.
        """
        self.calls = kwargs.get(
            'calls', [])
        """
        The variant calls for this particular variant. Each one
        represents the   determination of genotype with respect to
        this variant. Calls in this array   are implicitly associated
        with this Variant.
        """
        self.created = kwargs.get(
            'created', None)
        """
        The date this variant was created in milliseconds from the
        epoch.
        """
        self.end = kwargs.get(
            'end', None)
        """
        The end position (exclusive), resulting in [start, end)
        closed-open interval.   This is typically calculated by start
        + referenceBases.length.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The variant ID.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional variant information.
        """
        self.names = kwargs.get(
            'names', [])
        """
        Names for the variant, for example a RefSNP ID.
        """
        self.referenceBases = kwargs.get(
            'referenceBases', None)
        """
        The reference bases for this variant. They start at the given
        start position.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The reference on which this variant occurs.   (e.g. chr20 or
        X)
        """
        self.start = kwargs.get(
            'start', None)
        """
        The start position at which this variant occurs (0-based).
        This corresponds to the first base of the string of reference
        bases.   Genomic positions are non-negative integers less than
        reference length.   Variants spanning the join of circular
        genomes are represented as   two variants one on each side of
        the join (position 0).
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this variant was last updated in
        milliseconds from the epoch.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The ID of the VariantSet this variant belongs to. This
        transitively defines   the ReferenceSet against which the
        Variant is to be interpreted.
        """


class VariantSet(ProtocolElement):
    """
    Variant and CallSet both belong to a VariantSet. VariantSet
    belongs to a Dataset. The variant set is equivalent to a VCF file.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"doc": "", "type": "string", "name": "datasetId"}, {"doc":
"", "type": "string", "name": "referenceSetId"}, {"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'metadata', 'name', 'referenceSetId'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this variant set belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The variant set ID.
        """
        self.metadata = kwargs.get(
            'metadata', [])
        """
        The metadata associated with this variant set. This is
        equivalent to   the VCF header information not already
        presented in first class fields.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The variant set name.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The reference set the variants in this variant set are using.
        """


class VariantSetMetadata(ProtocolElement):
    """
    This metadata represents VCF header information.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "description",
        "id",
        "key",
        "number",
        "type",
        "value",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'key', 'number', 'type', 'value'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A textual description of this metadata.
        """
        self.id = kwargs.get(
            'id', None)
        """
        User-provided ID field, not enforced by this API.   Two or
        more pieces of structured metadata with identical   id and key
        fields are considered equivalent.
        """
        self.info = kwargs.get(
            'info', {})
        """
        Remaining structured metadata key-value pairs.
        """
        self.key = kwargs.get(
            'key', None)
        """
        The top-level key.
        """
        self.number = kwargs.get(
            'number', None)
        """
        The number of values that can be included in a field described
        by this   metadata.
        """
        self.type = kwargs.get(
            'type', None)
        """
        The type of data.
        """
        self.value = kwargs.get(
            'value', None)
        """
        The value field for simple metadata.
        """


class Wiggle(ProtocolElement):
    """
    Continuous numerical annotation of a region.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Wiggle",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "referenceName"}, {"default": null, "type": ["null", "long"],
"name": "start"}, {"default": null, "type": ["null", "long"], "name":
"end"}, {"default": [], "doc": "", "type": {"items": "float", "type":
"array"}, "name": "values"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'referenceName', 'start', 'values'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        No documentation
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The oriented piece of sequence being annotated.     Note that
        we are fusing parts of UCSC BedGraph and Wiggle syntax.
        The segment is being fully annotated, but can be divided into
        bins.     If you have gaps, you need to define a sequence of
        such Wiggles.          All three of referenceName, start, and
        end must be specified as a     group.
        """
        self.start = kwargs.get(
            'start', None)
        """
        No documentation
        """
        self.values = kwargs.get(
            'values', [])
        """
        The values associated to this region.     If this list
        contains _count_ elements, then the region is divided     as
        cleanly as possible into _count_ bins of equal width.     We
        thus define a numerical function:      value(position):
        if position < start or position >= start + length:
        return None       else:         return array[floor((position -
        start)*count/length)]
        """


class WiggleSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"WiggleSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": {"doc": "", "type": "record", "name":
"Attributes", "fields": [{"default": {}, "type": {"values": {"items":
["string", {"doc": "", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}]}, {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}]}], "type": "array"}, "type": "map"}, "name": "vals"}]},
"name": "attributes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'id'
    ]

    def __init__(self, **kwargs):
        self.attributes = kwargs.get(
            'attributes', None)
        """
        Set of additional attributes
        """
        self.id = kwargs.get(
            'id', None)
        """
        Id of this annotation node.
        """

postMethods = \
    [('/callsets/search',
      SearchCallSetsRequest,
      SearchCallSetsResponse),
     ('/datasets/search',
      SearchDatasetsRequest,
      SearchVariantsResponse),
     ('/genotypephenotype/search',
      SearchGenotypePhenotypeRequest,
      SearchReferencesResponse),
     ('/readgroupsets/search',
      SearchReadGroupSetsRequest,
      SearchReadsResponse),
     ('/reads/search',
      SearchReadsRequest,
      SearchReferenceSetsResponse),
     ('/references/search',
      SearchReferencesRequest,
      SearchReadGroupSetsResponse),
     ('/referencesets/search',
      SearchReferenceSetsRequest,
      SearchDatasetsResponse),
     ('/variants/search',
      SearchVariantsRequest,
      SearchVariantSetsResponse),
     ('/variantsets/search',
      SearchVariantSetsRequest,
      SearchGenotypePhenotypeResponse)]
